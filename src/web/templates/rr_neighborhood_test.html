<!DOCTYPE html>
<html>
<head>
		<meta charset='utf-8' />
		<title>Show drawn polygon area</title>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
        <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.js'></script>
		<link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.5.0/mapbox-gl.css' rel='stylesheet' />
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.2.3/flatpickr.css">
        
        <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.js'></script>
		<link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.css' type='text/css' />
	<style>
            body { margin:0; padding:0; }
            #map { position:absolute; top:0; bottom:0; width: 80%; }
            .marker {
    			border: none;
    			cursor: pointer;
    			height: 32px;
    			width: 32px;
    			background-image: url(static/marker.png);
    			background-color: rgba(0, 0, 0, 0);
    			transform: translate(28px, 56px, 0);
			}
			.container{
    			height: 100vh;
    			display: -webkit-flex;
    			display: flex;
    			-webkit-flex-direction: row;
    			flex-direction: row;
			}
			.fixed{
    			width: 20%;
			}
			.flex-item{
    			flex-grow: 1;
			}
			.flatpickr-calendar{
				font-size: 12px;
			}

			/* Remove default bullets */
			ul, #list_neighborhoods {
  				list-style-type: none;
			}

			/* Remove margins and padding from the parent ul */
			#list_neighborhoods {
  				margin: 5px;
  				padding: 0;
			}

			/* Style the caret/arrow */
			.caret {
  				cursor: pointer;
  				user-select: none; /* Prevent text selection */
			}

			/* Create the caret/arrow with a unicode, and style it */
			.caret::before {
  				content: "\25B6";
  				color: black;
  				display: inline-block;
  				margin-right: 6px;
			}

			/* Rotate the caret/arrow icon when clicked on (using JavaScript) */
			.caret-down::before {
  				transform: rotate(90deg);
			}

			/* Hide the nested list */
			.nested {
  				display: none;
			}

			/* Show the nested list when the user clicks on the caret/arrow (with JavaScript) */
			.active {
  				display: block;
			}	
			
      </style>
</head>
<body>
	<div class="container">
    	<div id="slidemenu" class = "fixed">
			<div class="input" id="input_frame">
				<h4>Choose points from the map</h4>
				<img src="static/letter_a.png"> <input type="text" id="inputSource" value="" readonly><br>
				
				<div class="input" id="target_add">
				<img src="static/letter_b.png"> <input type="text" id="inputTarget" value="" readonly> 
				<button id="new_target" value="Add" onClick="add()" style="display:none; position:relative;">+</button>
				</div>
				<div class="input" id="input_target"></div>
				<br><br>
				<div id="neig_list_div">
					<ul id="list_neighborhoods">
					</ul>
				</div>
				<br><br>
                <select id="select_departure" onchange="departure(this.value)">
  					<option value="now">Leave now</option>
  					<option value="later">Depart at</option>
				</select>
				<input type="text" style="display:none;" id="dateTimePicker" placeholder="Please select Date Time" data-input>
				<br><br>
				<button class="clearbutton" id="clear_button" onClick="clearFields()">Clear</button> <button class="button" id="getResults" onClick="getResults()">Get Directions</button>
			</div>

		</div>
		
        <div data-role="page" id="main_page" data-theme="a" class = "flex-item">
			<div class="map_container" data-role="content">
				<div id="map"></div>
				<div class="shadow"></div>
			</div>
		</div>
	</div>

	<script>
	mapboxgl.accessToken = '{{ ACCESS_KEY }}';
    var map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v9',
        center: [13.4050, 52.5200],
        zoom: 10
    });

    polygons = {{polygons|safe}}
    var parentMap = null;

    //$( document ).ready(function() {
        //console.log( "ready!" );
        parentMap = new Map();
        var minLevelNeig = Number.MAX_SAFE_INTEGER;
        var minLevel = Number.MAX_SAFE_INTEGER;
    	polygons.features.forEach(function (feature) {
        	  var id = feature.id;
        	  var name = feature.properties.name;
        	  var level = feature.properties.level;
        	  var parent = feature.properties.parent;
    		  //console.log(id, name, level, parent);

    		  if(level < minLevel){
        		  minLevel = level;
        		  minLevelNeig = id;
        	  }

    		  if(parentMap.get(parent)){
        		  listChildren = parentMap.get(parent);
        		  listChildren.push({"id": id, "name":name, "level": level, "parent": parent});
        		  parentMap.set(parent, listChildren);
        		  
        	  }else{
        		  parentMap.set(parent, [{"id": id, "name":name, "level": level, "parent": parent}]);
              }
    		  
    	});
    	//console.log(parentMap)
    	//console.log(minLevel)

    	var list = document.getElementById('list_neighborhoods');
    	parentMap.get(minLevelNeig).forEach(function (child) {
        	//console.log(child);
        	buildNeighborhoodList(child["id"], child["name"], child["level"], child["parent"], list);
    	});

    //});


    var hoveredStateId =  null;
    map.on('load', function () {
    	map.addSource("polygons", {
    	"type": "geojson",
    	"data": polygons
    	});

    	// The feature-state dependent fill-opacity expression will render the hover effect
    	// when a feature's hover state is set to true.
    	map.addLayer({
    		"id": "polygon-fills",
    		"type": "fill",
    		"source": "polygons",
    		"layout": {},
    		"paint": {
    		"fill-color": "#627BC1",
    		"fill-opacity": ["case",
    		["boolean", ["feature-state", "hover"], false],
    			0.5,
    			0
    		]
    		}
    	});
    	 
    	// When the user moves their mouse over the state-fill layer, we'll update the
    	// feature state for the feature under the mouse.
    	/*map.on("mousemove", "polygon-fills", function(e) {
    		if (e.features.length > 0) {
    			//console.log(e.features[0])
    			//console.log(e.features[0].properties)
    			//console.log(e.features[0].properties.id)
    			if (hoveredStateId) {
    				console.log("hoveredStateId not empty!")
    				map.setFeatureState({source: 'polygons', id: hoveredStateId}, { hover: false});
    			}
    			hoveredStateId = e.features[0].id;
    			//hoveredStateId = e.features[0].properties.id;
    			console.log(hoveredStateId)
    			map.setFeatureState({source: 'polygons', id: hoveredStateId}, { hover: true});
    		}
    	});
    	 
    	// When the mouse leaves the state-fill layer, update the feature state of the
    	// previously hovered feature.
    	map.on("mouseleave", "polygon-fills", function() {
    		if (hoveredStateId) {
    			map.setFeatureState({source: 'polygons', id: hoveredStateId}, { hover: false});
    		}
    		hoveredStateId =  null;
    	});*/

    });

    var draw = null;

    var timer = 0;
    var delay = 250;
    var prevent = false;

    var markers = []
    var popups = []

   	var startLon = -1;
	var startLat = -1;

	var timestamp = new Date().getTime();
    var time_changed = false;

    /*$(document).on('click',function(event){
        console.log("clicking document");
        console.log(event.target)
    });*/

    function buildNeighborhoodList(nid, name, level, parent, list){
    	//console.log(nid, name);
    	
    	if(!parentMap.get(nid)){
        	//console.log("leaf reached:" + nid);
    		var entry = document.createElement('li');
    	    entry.appendChild(document.createTextNode(name));
    	    var checkbox = document.createElement("INPUT");
    	    checkbox.setAttribute("type", "checkbox");
    	    checkbox.setAttribute("id", nid);
    	    checkbox.classList.add('checkbox_list');
    	    entry.appendChild(checkbox);
    	    entry.setAttribute("id", "n"+nid);
    	    list.appendChild(entry);
        }else{
        	//console.log("node has children:" + nid);
        	var entry = document.createElement('li');
    	    var span = document.createElement('span');
    	    span.classList.add('caret');
    	    entry.appendChild(span);
    	    entry.appendChild(document.createTextNode(name));
    	    var checkbox = document.createElement("INPUT");
    	    checkbox.setAttribute("type", "checkbox");
    	    checkbox.setAttribute("id", nid);
    	    checkbox.classList.add('checkbox_list');
    	    entry.appendChild(checkbox);
    	    entry.setAttribute("id", "n"+nid);
    	    list.appendChild(entry);

    	    var listNeig = document.getElementById("n"+nid);
    	    var entry1 = document.createElement('ul');
    	    entry1.classList.add('nested');
    	    entry1.setAttribute("id", "ul_n"+nid);
    	    listNeig.appendChild(entry1);

    	    var listUl = document.getElementById("ul_n"+nid);

    	    parentMap.get(nid).forEach(function (child) {
            	buildNeighborhoodList(child["id"], child["name"], child["level"], child["parent"], listUl);
        	});
        }
    }


    var toggler = document.getElementsByClassName("caret");
    var i;

    for (i = 0; i < toggler.length; i++) {
      //console.log(toggler[i])
      toggler[i].addEventListener("click", function() {
        this.parentElement.querySelector(".nested").classList.toggle("active");
        this.classList.toggle("caret-down");
      });
    }

    const checkboxes = document.getElementsByClassName("checkbox_list");
    //console.log(checkboxes);
    for (i = 0; i < checkboxes.length; i++) {
        //console.log(checkboxes[i])
        //console.log(checkboxes[i].id)
        checkboxes[i].addEventListener("change", function() {
        	if(this.checked) {
                console.log(this.id + " checked")
                map.setFeatureState({source: 'polygons', id: this.id}, { hover: true});
            } else {
                // Checkbox is not checked..
            	map.setFeatureState({source: 'polygons', id: this.id}, { hover: false});
            }
        });
      }
	
    map.on('click', function(e) {
    	timer = setTimeout(function() {
            if (!prevent) {
            	var latitude = e.lngLat.lat;
                var longitude = e.lngLat.lng;
                //doWork()
                
				var str = Number((latitude).toFixed(6)) + "," + Number((longitude).toFixed(6));

				var coord = { lat:latitude, lon:longitude }
				console.log(coord.lat)
	
                console.log(str)
                
                //if(document.getElementById('inputSource').hidden == false) { 
                	if(document.getElementById('inputSource').value == "") {
        				//add marker
                        // create a HTML element for each feature
                        startLon = longitude;
    					startLat = latitude;
    					
            			var el = document.createElement('div');
            			el.className = 'marker';
            			el.style.right = '-5px';
                        el.style.top = '-12px';

                        el.addEventListener('click', e => {
                            e.stopPropagation();
                            //functions
                            console.log("source" + " clicked")
                            
                            var popup = new mapboxgl.Popup({closeOnClick: false, anchor: 'top'})
                            .setLngLat({lat:latitude, lng: longitude})
                            .setHTML("<strong>source</strong>")
                            .addTo(map);

                            popup.on('close', function(e) {
                                console.log("popup closed")
                            })

                            popups.push(popup);
                            
                        }, true);

            			// make a marker for each feature and add to the map
            			var marker = new mapboxgl.Marker(el)
              				.setLngLat(e.lngLat)
              				.addTo(map);
          				
              			markers.push(marker);

              			document.getElementById('inputSource').value = str;

              			document.getElementById('inputTarget').value = "Select polygon";


              			if(!draw) {
            				draw = new MapboxDraw({
            					displayControlsDefault: false,
            					controls: {
            					}
            				});
            				map.addControl(draw);

            				draw.changeMode('draw_polygon');
            			 
            				map.on('draw.create', updateArea);
            				map.on('draw.delete', updateArea);
            				map.on('draw.update', updateArea);
              			}
    					
        			}
            }
            prevent = false;
        }, delay);
    });

    function departure(selectedValue) {
        time_changed = true;
        console.log(selectedValue)
        if(selectedValue == "later"){
        	var picker = document.getElementById ( "dateTimePicker" ) ;
        	picker.style.display = "inline" ;
        	$("#dateTimePicker").flatpickr({
        		enableTime: true,
        		dateFormat: "F, d Y H:i",
        		defaultDate: new Date().getTime(),
        		onChange: function(selectedDates, dateStr, instance) {
                    selectedDates.forEach(function (date){
    					//console.log(date)
                        //console.log(date.getFullYear(), date.getDate(), date.getMonth(), date.getTime());
                        timestamp = date.getTime()
                        //console.log(timestamp)
                    })
                }
    		});
        }
        if(selectedValue == "now"){
        	var picker = document.getElementById ( "dateTimePicker" ) ;
        	picker.style.display = "none" ;
        	timestamp = new Date().getTime()
        }
    }
    
    function clearFields() {
        console.log("clearing map")
    	document.getElementById('inputSource').value = "";
    	document.getElementById('inputTarget').value = "";

		draw.deleteAll();
		map.removeControl(draw);
		draw = null;
    	var j;
    	for (j = 0; j < markers.length; j++) {
    		markers[j].remove();
    		if (popups[j]){
    			popups[j].remove();
        	}
    	}

		if (map.getLayer("rr_layer")) {
		    map.removeLayer("rr_layer");
		}

		if (map.getSource("rr_layer")) {
		    map.removeSource("rr_layer");
		}

		var picker = document.getElementById ( "dateTimePicker" ) ;
    	picker.style.display = "none" ;

    	$("#select_departure").val('now');
    	time_changed = false;
		
    	startLon = -1;
    	startLat = -1;
    	markers = []
    	popups = []
    }
    
    function getResults() {
    	//console.log(startLon, startLat, targets.length) 
    	if(startLon == -1 || startLat == -1 || !polygon_coords) {
    		alert("Some coordinates are missing."); 
       	}
       	else if(isNaN(startLon) || isNaN(startLat)) {
    		alert("Coordinates are not defined correctly."); 
       	}
       	else {
    		// ajax the JSON to the server
    		if(!time_changed){
    			timestamp = new Date().getTime();
        	}
    		console.log(timestamp)
    		var data_input = {"startLon": startLon, "startLat": startLat, "coordinates":polygon_coords, "timestamp":timestamp}
			
    		$.post("receiver_region", JSON.stringify(data_input) , function(res){
				console.log(res)
				map.addLayer({
                    "id": "rr_layer",
                    "type": "circle",
                    "source": {
	                    "type": "geojson",
	                    "data": res
	                },
                    'paint': {
                    	'circle-radius': 10,
                    	// color circles by rr
                    	// https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-match
                    	'circle-color': [
							'match',
							['get', 'marker-color'],
							"r", '#ff0000',
							"b", '#223b53',
							/* other */ '#ccc'
						]
                    }
                });
				
    		}); 
       	}        
    }

    function addPathLayer(marker_id, geom){
    	map.addLayer({
            "id": "paths"+marker_id,
            "type": "line",
            "source": {
                "type": "geojson",
                "data": geom
            },
            "layout": {
                "line-join": "round",
                "line-cap": "round"
            },
            'paint': {
            	"line-width": 6,
            	// color routes by type
            	// https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions-match
            	'line-color': [
					'match',
					['get', 'line-color'],
					"r", '#ff0000',
					"b", '#223b53',
					/* other */ '#ccc'
				]
            }
        });
    }

	var polygon_coords = null;
	function updateArea(e) {
	if (e.type == 'draw.create' || e.type == 'draw.update'){
		var data = draw.getAll();
		console.log(data);
		console.log(data.features);
		//console.log(data.features[0].geometry.coordinates);
		polygon_coords = data.features[0].geometry.coordinates;
		console.log(polygon_coords);
	}else if (e.type == 'draw.delete'){
		polygon_coords = null;
	}

}
 
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.2.3/flatpickr.js"></script>
</body>
</html>