(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.DrawAssistedRectangle = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var doubleClickZoom = {
  enable: function enable(ctx) {
    setTimeout(function () {
      // First check we've got a map and some context.
      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;

      if (!ctx._ctx.store.getInitialConfigValue("doubleClickZoom")) return;
      ctx.map.doubleClickZoom.enable();
    }, 0);
  },
  disable: function disable(ctx) {
    setTimeout(function () {
      if (!ctx.map || !ctx.map.doubleClickZoom) return;

      ctx.map.doubleClickZoom.disable();
    }, 0);
  }
};

var DrawAssistedRectangle = {

		  // When the mode starts this function will be called.
		  onSetup: function(opts) {
		    const rectangle = this.newFeature({
		      type: "Feature",
		      properties: {},
		      geometry: {
		        type: "Polygon",
		        coordinates: [[]]
		      }
		    });
		    this.addFeature(rectangle);
		    this.clearSelectedFeatures();
		    doubleClickZoom.disable(this);
		    this.updateUIClasses({ mouse: "add" });
		    this.setActionableState({
		      trash: true
		    });
		    return {
		      rectangle
		    };
		  },
		  // support mobile taps
		  onTap: function(state, e) {
		    // emulate 'move mouse' to update feature coords
		    if (state.startPoint) this.onMouseMove(state, e);
		    // emulate onClick
		    this.onClick(state, e);
		  },
		  clickAnywhere: function(state, e) {
			  console.log("click anywhere")
			  //if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {
				  this.changeMode("direct_select", { featureId: state.rectangle.id });
			  //}
		  },
		  // Whenever a user clicks on the map, Draw will call `onClick`
		  onClick: function(state, e) {
		    // if state.startPoint exist, means its second click
		    //change to  simple_select mode
			console.log("clicking")
		    if (
		      state.startPoint &&
		      state.startPoint[0] !== e.lngLat.lng &&
		      state.startPoint[1] !== e.lngLat.lat
		    ) {
		      this.updateUIClasses({ mouse: "pointer" });
		      state.endPoint = [e.lngLat.lng, e.lngLat.lat];
		      console.log("rectangle id:" + state.rectangle.id)
		      this.changeMode("simple_select", { featuresId: state.rectangle.id });
		    }
		    // on first click, save clicked point coords as starting for  rectangle
		    const startPoint = [e.lngLat.lng, e.lngLat.lat];
		    state.startPoint = startPoint;
		  },
		  onMouseMove: function(state, e) {
		    // if startPoint, update the feature coordinates, using the bounding box concept
		    // we are simply using the startingPoint coordinates and the current Mouse Position
		    // coordinates to calculate the bounding box on the fly, which will be our rectangle
		    if (state.startPoint) {
		      state.rectangle.updateCoordinate(
		        "0.0",
		        state.startPoint[0],
		        state.startPoint[1]
		      ); //minX, minY - the starting point
		      state.rectangle.updateCoordinate(
		        "0.1",
		        e.lngLat.lng,
		        state.startPoint[1]
		      ); // maxX, minY
		      state.rectangle.updateCoordinate("0.2", e.lngLat.lng, e.lngLat.lat); // maxX, maxY
		      state.rectangle.updateCoordinate(
		        "0.3",
		        state.startPoint[0],
		        e.lngLat.lat
		      ); // minX,maxY
		      state.rectangle.updateCoordinate(
		        "0.4",
		        state.startPoint[0],
		        state.startPoint[1]
		      ); //minX,minY - ending point (equals to starting point)
		    }
		  },
		  // Whenever a user clicks on a key while focused on the map, it will be sent here
		  onKeyUp: function(state, e) {
			  console.log("on key up")
		    if (e.keyCode === 27) return this.changeMode("simple_select");
		  },
		  clickNoTarget: function () {
			  console.log("clickNoTarget")
			  this.changeMode("simple_select");
		  },

		  clickInactive: function () {
			  console.log("clickInactive")
			  this.changeMode("simple_select");
		  },
		  
		  onStop: function(state) {
			console.log("stopping")
		    doubleClickZoom.enable(this);
		    this.updateUIClasses({ mouse: "none" });
		    this.activateUIButton();

		    // check to see if we've deleted this feature
		    if (this.getFeature(state.rectangle.id) === undefined) return;

		    //remove last added coordinate
		    state.rectangle.removeCoordinate("0.4");
		    if (state.rectangle.isValid()) {
		      this.map.fire("draw.create", {
		        features: [state.rectangle.toGeoJSON()]
		      });
		    } else {
		      this.deleteFeature([state.rectangle.id], { silent: true });
		      this.changeMode("simple_select", {}, { silent: true });
		    }
		  },
		  toDisplayFeatures: function(state, geojson, display) {
		    const isActivePolygon = geojson.properties.id === state.rectangle.id;
		    geojson.properties.active = isActivePolygon ? "true" : "false";
		    if (!isActivePolygon) return display(geojson);

		    // Only render the rectangular polygon if it has the starting point
		    if (!state.startPoint) return;
		    return display(geojson);
		  },
		  onTrash: function(state) {
			console.log("deleting");
		    this.deleteFeature([state.rectangle.id], { silent: true });
		    this.changeMode("simple_select");
		  }
		};

exports.default = DrawAssistedRectangle;
},{}]},{},[1])(1)
});
